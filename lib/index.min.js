"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mapStatesToProps=mapStatesToProps,exports.dispatch=dispatch,exports.connect=connect;var _fluxibleJs=require("fluxible-js"),_react=_interopRequireDefault(require("react")),_redefineStaticsJs=_interopRequireDefault(require("redefine-statics-js"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _extends(){return _extends=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends.apply(this,arguments)}function mapStatesToProps(a,b){function c(c){var d=this;this.props=c,this.state={count:0};var e=b((0,_fluxibleJs.getStore)());return this.componentWillUnmount=(0,_fluxibleJs.addObserver)(function(){e=b((0,_fluxibleJs.getStore)()),d.setState({count:d.state.count+1})},Object.keys(e)),this.render=function(){return _react.default.createElement(a,_extends({},d.props,e))},this}return c.prototype=_react.default.Component.prototype,c.prototype.constructor=c,c}/*
 * NOTICE:
 * FUNCTIONS BELOW ARE DEPRECATED AND WILL BE REMOVED IN THE NEXT MAJOR RELEASE.
 */ /**
 *
 * @param {Function} callback function that would be called sa the mutation handler.
 * @param  {...any} payload to the callback function
 */function dispatch(a){for(var b=arguments.length,c=Array(1<b?b-1:0),d=1;d<b;d++)c[d-1]=arguments[d];return a.apply(void 0,[{getStore:_fluxibleJs.getStore,updateStore:function c(a,b){(0,_fluxibleJs.updateStore)(a),b&&b()}}].concat(c))}/**
 * @param {Function} Would receive the current store's state as the only argument. Should return an object of the states that you want to be accessible in the connected component.
 * @param {Object} You should define your action handlers here. Each methods would be called with an object (that has `updateStore` and `getStore` methods) as the first argument. The rest would be the arguments you passed to the call.
 * @return {Object} the inferno component.
 */function connect(a,b){return function(c){function d(d){var f=this;return this.props=d,a&&(this.mappedStates=a((0,_fluxibleJs.getStore)()),this.removeListener=(0,_fluxibleJs.addObserver)(function(){f.mappedStates=a((0,_fluxibleJs.getStore)()),f.setState({count:f.state.count+1})},Object.keys(this.mappedStates)),this.state={count:0}),this.componentWillUnmount=function(){f.removeListener&&f.removeListener()},this.render=function(){return a&&b?_react.default.createElement(c,_extends({},f.props,e,f.mappedStates)):a?_react.default.createElement(c,_extends({},f.props,f.mappedStates)):_react.default.createElement(c,_extends({},f.props,e))},this}// we only want to compute mutations once
var e={};return b&&function(){for(var c=Object.keys(b),d=function(d){e[c[d]]=function(){for(var a=arguments.length,e=Array(a),f=0;f<a;f++)e[f]=arguments[f];return dispatch.apply(void 0,[b[c[d]]].concat(e))}},f=0;f<c.length;f++)d(f)}(),d.prototype=_react.default.Component.prototype,d.prototype.constructor=d,(0,_redefineStaticsJs.default)(d,c),d}}